package com.spacesimulation.display;

import java.awt.Canvas;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseEvent;
import java.awt.image.BufferStrategy;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPopupMenu;

public class ViewFrameImpl extends javax.swing.JFrame implements ViewFrame {

    private final HashMap<String, ConsoleItem> points = new HashMap<String, ConsoleItem>();
    private ViewLoop viewLoop;
    private String info = "";
    private boolean grid = true;

    /** Creates new form NewJFrame */
    public ViewFrameImpl() {
        initComponents();
        setTitle("Space View Frame");
        gui.setSize(ViewManager.getXSize(), ViewManager.getYSize());
        pack();
        setVisible(true);

        viewLoop = new ViewLoop(gui);
        Thread gameThread = new Thread(viewLoop);
        gameThread.setPriority(Thread.MIN_PRIORITY);
        gameThread.start(); // start Game processing.
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        gui = new java.awt.Canvas();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setResizable(false);

        gui.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                guiMouseClicked(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(gui, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(gui, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    public void toggleGrid() {
        if (grid) {
            grid = false;
        } else {
            grid = true;
        }
    }

    private void guiMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_guiMouseClicked
        if (evt.getButton() == MouseEvent.BUTTON1) {
            JOptionPane.showMessageDialog(this, findClosest(evt.getPoint()));
        } else if (evt.getButton() == MouseEvent.BUTTON3) {
            JPopupMenu pop = new JPopupMenu();

            JMenuItem menuItem = new JMenuItem("Toggle Grid");
            menuItem.addActionListener(new ActionListener() {

                public void actionPerformed(ActionEvent e) {
                    ViewManager.getInstance().toggleGrid();
                }
            });
            pop.add(menuItem);


            String s = "Pause Simulation";
            if (ViewManager.getInstance().isPaused()) {
                s = "Resume Simulation";
            }
            menuItem = new JMenuItem(s);
            menuItem.addActionListener(new ActionListener() {

                public void actionPerformed(ActionEvent e) {
                    if (ViewManager.getInstance().isPaused()) {
                        ViewManager.getInstance().resume();
                    } else {
                        ViewManager.getInstance().pause();
                    }
                }
            });
            pop.add(menuItem);


            menuItem = new JMenuItem("Stop Simulation");
            menuItem.addActionListener(new ActionListener() {

                public void actionPerformed(ActionEvent e) {
                    ViewManager.getInstance().stop();
                }
            });
            pop.add(menuItem);
            pop.show(evt.getComponent(), evt.getX(), evt.getY());
        }
    }//GEN-LAST:event_guiMouseClicked

    public int getXSize() {
        return ViewManager.getXSize();
    }

    public int getYSize() {
        return ViewManager.getYSize();
    }

    public int getZSize() {
        return ViewManager.getZSize();
    }

    public void updateInfo(String s) {
        info = s;
    }

    public boolean isStopped() {
        return !viewLoop.isRunning();
    }

    public void stop() {
        viewLoop.stopRunning();
    }

    public void resume() {
        viewLoop.setPaused(false);
    }

    public void pause() {
        viewLoop.setPaused(true);
    }

    public boolean isPaused() {
        return viewLoop.isPaused();
    }

    public void updateItem(ConsoleItem ci) {
        synchronized (points) {
            points.put(ci.getId(), ci);
        }
    }

    private ConsoleItem findClosest(Point p) {
        double distance = Integer.MAX_VALUE;
        ConsoleItem closest = null;

        synchronized (points) {
            for (ConsoleItem ci : points.values()) {
                double d = p.distance(ci.getLocation().getX(), ci.getLocation().getY());
                if (d < distance) {
                    distance = d;
                    closest = ci;
                }
            }
        }
        return closest;
    }

    public int numItems() {
        return points.size();
    }

    public void clearAllItems() {
        synchronized (points) {
            points.clear();
        }
    }

    public void removeItem(String id) {
        synchronized (points) {
            points.remove(id);
        }
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private java.awt.Canvas gui;
    // End of variables declaration//GEN-END:variables

    private class ViewLoop implements Runnable {

        private static final int FRAME_DELAY = 20; // 20ms. implies 50fps (1000/20) = 50
        private boolean isRunning;
        private boolean paused;
        private Canvas gui;
        private long cycleTime;

        public ViewLoop(Canvas canvas) {
            gui = canvas;
            isRunning = true;
        }

        public void stopRunning() {
            isRunning = false;
        }

        public boolean isPaused() {
            return paused;
        }

        public void setPaused(boolean value) {
            paused = value;
        }

        public boolean isRunning() {
            return isRunning;
        }

        public void run() {
            cycleTime = System.currentTimeMillis();
            gui.createBufferStrategy(2);
            BufferStrategy strategy = gui.getBufferStrategy();

            // View Loop
            while (isRunning) {
                updateGUI(strategy);
                synchFramerate();
            }

            try {
                Thread.sleep(500);
            } catch (InterruptedException ex) {
                Logger.getLogger(ViewFrameImpl.class.getName()).log(Level.SEVERE, null, ex);
            }

            System.exit(0);
        }

        private void updateGUI(BufferStrategy strategy) {

            Graphics g = strategy.getDrawGraphics();

            g.setColor(Color.black);
            g.fillRect(0, 0, gui.getWidth(), gui.getHeight());

            ArrayList<ConsoleItem> allItems = null;
            synchronized (points) {
                allItems = new ArrayList<ConsoleItem>(points.values());
            }

            for (ConsoleItem ci : allItems) {
                if (ci.isDestroyed()) {
                    synchronized (points) {
                        points.remove(ci.getId());
                    }
                    continue;
                }
                g.setColor((ci.isDamaged() ? ci.getColor().darker() : ci.getColor()));
                g.fillPolygon(ci.getPolygon(getZSize()));
            }

            drawLegend(g);
            drawCoords(g);
            if (grid) {
                drawGrid(g);
            }

            drawSummary(g);

            g.dispose();
            strategy.show();
        }

        private void drawLegend(Graphics g) {
            g.setColor(Color.white);
            g.drawString("X", gui.getWidth() - 15, 15);
            g.drawLine(gui.getWidth() - 75, 10, gui.getWidth() - 20, 10);
            g.drawString("Y", gui.getWidth() - 15, 30);
            g.drawLine(gui.getWidth() - 11, 33, gui.getWidth() - 11, 83);
            g.drawString("Z", gui.getWidth() - 25, 27);
            g.drawLine(gui.getWidth() - 30, 30, gui.getWidth() - 65, 65);

        }

        private void drawSummary(Graphics g) {
            g.setColor(Color.white);
            g.drawString(info, 5, gui.getHeight() - 5);
        }

        private void drawCoords(Graphics g) {
            g.setColor(Color.white);
            g.drawString("(0, 0)", 5, 12);
            g.drawString("(" + gui.getWidth() + ", " + gui.getHeight() + ")", gui.getWidth() - 65, gui.getHeight() - 5);
        }

        private void drawGrid(Graphics g) {
            g.setColor(Color.darkGray);
            double xSpace = gui.getWidth() / 50.0;
            double ySpace = gui.getHeight() / 50.0;

            // Horiz
            for (int y = 0; y < ySpace; y++) {
                g.drawLine(0, y * 50, gui.getWidth(), y * 50);
            }

            // Vert
            for (int x = 0; x < xSpace; x++) {
                g.drawLine(x * 50, 0, x * 50, gui.getHeight());
            }
        }

        private void synchFramerate() {
            cycleTime = cycleTime + FRAME_DELAY;
            long difference = cycleTime - System.currentTimeMillis();
            try {
                Thread.sleep(Math.max(0, difference));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
